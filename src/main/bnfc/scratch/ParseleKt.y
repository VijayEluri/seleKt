-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParseleKt where
import AbsseleKt
import LexseleKt
import ErrM
}

%name pRecordExpr RecordExpr
%name pRecordExpr2 RecordExpr2
%name pRecordExpr3 RecordExpr3
%name pRecordExpr1 RecordExpr1
%name pBinding Binding
%name pRecordPtn RecordPtn
%name pRecordVariable RecordVariable
%name pCollectionExpr CollectionExpr
%name pExtensionBodyExpr ExtensionBodyExpr
%name pIntensionBodyExpr IntensionBodyExpr
%name pDomainDeclOrCond DomainDeclOrCond
%name pDomainGen DomainGen
%name pDomainCond DomainCond
%name pDomainPtn DomainPtn
%name pDomainExpr DomainExpr
%name pRecordSource RecordSource
%name pDomainCondition DomainCondition
%name pDomainCondition1 DomainCondition1
%name pDomainCondition2 DomainCondition2
%name pModality Modality
%name pRLambdaPCtxt RLambdaPCtxt
%name pRLambdaPCtxt1 RLambdaPCtxt1
%name pRLambdaPCtxt2 RLambdaPCtxt2
%name pContinuePCtxt ContinuePCtxt
%name pFormalPCtxt FormalPCtxt
%name pValuePCtxt ValuePCtxt
%name pValuePCtxt1 ValuePCtxt1
%name pValuePCtxt2 ValuePCtxt2
%name pValuePCtxt3 ValuePCtxt3
%name pRLambdaLCtxt RLambdaLCtxt
%name pRLambdaLCtxt1 RLambdaLCtxt1
%name pRLambdaLCtxt2 RLambdaLCtxt2
%name pContinueLCtxt ContinueLCtxt
%name pFormalLCtxt FormalLCtxt
%name pValueLCtxt ValueLCtxt
%name pValueLCtxt1 ValueLCtxt1
%name pValueLCtxt2 ValueLCtxt2
%name pValueLCtxt3 ValueLCtxt3
%name pValuePCtxtHole ValuePCtxtHole
%name pValueLCtxtHole ValueLCtxtHole
%name pLogicalGround LogicalGround
%name pComparison Comparison
%name pRLambdaExpr RLambdaExpr
%name pRLambdaExpr1 RLambdaExpr1
%name pRLambdaExpr2 RLambdaExpr2
%name pContinueExpr ContinueExpr
%name pFormalExpr FormalExpr
%name pValueExpr ValueExpr
%name pValueExpr1 ValueExpr1
%name pValueExpr2 ValueExpr2
%name pValueExpr3 ValueExpr3
%name pValueLiteral ValueLiteral
%name pStoreURL StoreURL
%name pWireURL WireURL
%name pURL URL
%name pURLPath URLPath
%name pURLLocation URLLocation
%name pURLRsrcLocation URLRsrcLocation
%name pURLRelativePath URLRelativePath
%name pURLRoot URLRoot
%name pNetLocation NetLocation
%name pURLScheme URLScheme
%name pURLPathElement URLPathElement
%name pDNSElement DNSElement
%name pPort Port
%name pListBinding ListBinding
%name pListDomainDeclOrCond ListDomainDeclOrCond
%name pListDomainExpr ListDomainExpr
%name pListDomainPtn ListDomainPtn
%name pListFormalExpr ListFormalExpr
%name pListRLambdaExpr1 ListRLambdaExpr1
%name pListFormalPCtxt ListFormalPCtxt
%name pListRLambdaPCtxt1 ListRLambdaPCtxt1
%name pListFormalLCtxt ListFormalLCtxt
%name pListRLambdaLCtxt1 ListRLambdaLCtxt1
%name pListURLPathElement ListURLPathElement
%name pListDNSElement ListDNSElement

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '&' { PT _ (TS "&") }
 '|' { PT _ (TS "|") }
 '::' { PT _ (TS "::") }
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }
 '=' { PT _ (TS "=") }
 '{:' { PT _ (TS "{:") }
 ':' { PT _ (TS ":") }
 ':}' { PT _ (TS ":}") }
 '_' { PT _ (TS "_") }
 '{' { PT _ (TS "{") }
 '}' { PT _ (TS "}") }
 '<-' { PT _ (TS "<-") }
 '?' { PT _ (TS "?") }
 '||' { PT _ (TS "||") }
 '~' { PT _ (TS "~") }
 '<' { PT _ (TS "<") }
 '>' { PT _ (TS ">") }
 ';' { PT _ (TS ";") }
 '.' { PT _ (TS ".") }
 '@' { PT _ (TS "@") }
 '+' { PT _ (TS "+") }
 '*' { PT _ (TS "*") }
 '-' { PT _ (TS "-") }
 '!' { PT _ (TS "!") }
 '[' { PT _ (TS "[") }
 ']' { PT _ (TS "]") }
 '==' { PT _ (TS "==") }
 '<=' { PT _ (TS "<=") }
 '>=' { PT _ (TS ">=") }
 '/' { PT _ (TS "/") }
 ',' { PT _ (TS ",") }
 'Nil' { PT _ (TS "Nil") }
 'false' { PT _ (TS "false") }
 'in' { PT _ (TS "in") }
 'lambda' { PT _ (TS "lambda") }
 'let' { PT _ (TS "let") }
 'newPrompt' { PT _ (TS "newPrompt") }
 'null' { PT _ (TS "null") }
 'pushPrompt' { PT _ (TS "pushPrompt") }
 'pushSubCont' { PT _ (TS "pushSubCont") }
 'record' { PT _ (TS "record") }
 'store' { PT _ (TS "store") }
 'true' { PT _ (TS "true") }
 'wire' { PT _ (TS "wire") }
 'withSubCont' { PT _ (TS "withSubCont") }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_UIdent { PT _ (T_UIdent $$) }
L_Wild { PT _ (T_Wild $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read $1) :: Integer }
Double  :: { Double }  : L_doubl  { (read $1) :: Double }
String  :: { String }  : L_quoted { $1 }
Char    :: { Char }    : L_charac { (read $1) :: Char }
UIdent    :: { UIdent} : L_UIdent { UIdent ($1)}
Wild    :: { Wild} : L_Wild { Wild ($1)}

RecordExpr :: { RecordExpr }
RecordExpr : RecordExpr '&' RecordExpr1 { Joined $1 $3 } 
  | RecordExpr1 '|' RecordExpr2 { Isolated $1 $3 }
  | RecordExpr1 { $1 }


RecordExpr2 :: { RecordExpr }
RecordExpr2 : DomainExpr '::' RecordExpr3 { Consed $1 $3 } 
  | RecordExpr3 { $1 }


RecordExpr3 :: { RecordExpr }
RecordExpr3 : 'let' ListBinding 'in' RecordExpr3 { Contexted $2 $4 } 
  | RecordVariable { Referenced $1 }
  | 'record' CollectionExpr { Collected $2 }
  | 'Nil' { Emptied }
  | '(' RecordExpr ')' { $2 }


RecordExpr1 :: { RecordExpr }
RecordExpr1 : RecordExpr2 { $1 } 


Binding :: { Binding }
Binding : RecordPtn '=' RecordPtn { BindingExpr $1 $3 } 


RecordPtn :: { RecordPtn }
RecordPtn : '{:' ListDomainPtn ':' RecordPtn ':}' { RecordDestructor $2 $4 } 
  | RecordExpr { RecordLiteral $1 }


RecordVariable :: { RecordVariable }
RecordVariable : UIdent { RecordIdent $1 } 
  | '_' { RecordWild }


CollectionExpr :: { CollectionExpr }
CollectionExpr : ExtensionBodyExpr { Extension $1 } 
  | IntensionBodyExpr { Intension $1 }


ExtensionBodyExpr :: { ExtensionBodyExpr }
ExtensionBodyExpr : '{' ListDomainExpr '}' { ExtensionBody $2 } 


IntensionBodyExpr :: { IntensionBodyExpr }
IntensionBodyExpr : '{' DomainPtn '|' ListDomainDeclOrCond '}' { IntensionBody $2 $4 } 


DomainDeclOrCond :: { DomainDeclOrCond }
DomainDeclOrCond : DomainCond { ConditionIn $1 } 
  | DomainGen { DeclIn $1 }


DomainGen :: { DomainGen }
DomainGen : DomainPtn '<-' RecordSource { DomainGenExpr $1 $3 } 


DomainCond :: { DomainCond }
DomainCond : DomainPtn 'in' DomainCondition { DomainSatExpr $1 $3 } 
  | ValueExpr Comparison ValueExpr { DomainCompExpr $1 $2 $3 }


DomainPtn :: { DomainPtn }
DomainPtn : '?' RLambdaPCtxt { DomainPtnExpr $2 } 


DomainExpr :: { DomainExpr }
DomainExpr : RLambdaExpr { DomainRLambdaExpr $1 } 


RecordSource :: { RecordSource }
RecordSource : RecordExpr { OnBoardSource $1 } 
  | 'store' StoreURL { PersistentSource $2 }
  | 'wire' WireURL { WireSource $2 }


DomainCondition :: { DomainCondition }
DomainCondition : DomainCondition '||' DomainCondition1 { DisjunctDomainCondition $1 $3 } 
  | DomainCondition1 { $1 }


DomainCondition1 :: { DomainCondition }
DomainCondition1 : DomainCondition1 '&' DomainCondition2 { ConjunctDomainCondition $1 $3 } 
  | DomainCondition2 { $1 }


DomainCondition2 :: { DomainCondition }
DomainCondition2 : '~' DomainCondition2 { NegatedDomainCondition $2 } 
  | '(' DomainCondition ')' { $2 }
  | '?' RLambdaLCtxt { StructuralDomainCondition $2 }
  | Modality DomainCondition2 { BehavioralDomainCondition $1 $2 }


Modality :: { Modality }
Modality : '<' DomainCondition2 '>' { ProbePossibility $2 } 


RLambdaPCtxt :: { RLambdaPCtxt }
RLambdaPCtxt : RLambdaPCtxt ListRLambdaPCtxt1 ';' { ApplicationPCtxt $1 (reverse $2) } 
  | RLambdaPCtxt1 { $1 }


RLambdaPCtxt1 :: { RLambdaPCtxt }
RLambdaPCtxt1 : 'lambda' ListFormalPCtxt '.' RLambdaPCtxt2 { AbstractionPCtxt $2 $4 } 
  | RLambdaPCtxt2 { $1 }


RLambdaPCtxt2 :: { RLambdaPCtxt }
RLambdaPCtxt2 : ContinuePCtxt { KPCtxt $1 } 
  | ValuePCtxt { GroundPCtxt $1 }
  | FormalPCtxt { MentionPCtxt $1 }
  | '(' RLambdaPCtxt ')' { $2 }


ContinuePCtxt :: { ContinuePCtxt }
ContinuePCtxt : 'pushPrompt' RLambdaPCtxt2 RLambdaPCtxt2 { PushPromptPCtxt $2 $3 } 
  | 'withSubCont' RLambdaPCtxt2 RLambdaPCtxt2 { SubcontPCtxt $2 $3 }
  | 'pushSubCont' RLambdaPCtxt2 RLambdaPCtxt2 { PushSubContPCtxt $2 $3 }


FormalPCtxt :: { FormalPCtxt }
FormalPCtxt : '@' '<' RLambdaPCtxt2 '>' { TranscriptPCtxt $3 } 


ValuePCtxt :: { ValuePCtxt }
ValuePCtxt : ValuePCtxt '+' ValuePCtxt1 { ValueAddPCtxt $1 $3 } 
  | ValuePCtxt1 { $1 }


ValuePCtxt1 :: { ValuePCtxt }
ValuePCtxt1 : ValuePCtxt1 '*' ValuePCtxt2 { ValueMultPCtxt $1 $3 } 
  | ValuePCtxt2 { $1 }


ValuePCtxt2 :: { ValuePCtxt }
ValuePCtxt2 : '-' ValuePCtxt3 { ValueNegPCtxt $2 } 
  | ValuePCtxt3 { $1 }


ValuePCtxt3 :: { ValuePCtxt }
ValuePCtxt3 : '!' ValueLiteral { ValueLitPCtxt $2 } 
  | ValuePCtxtHole { ValueEmptyPCtxt $1 }
  | '[' ValuePCtxt ']' { $2 }


RLambdaLCtxt :: { RLambdaLCtxt }
RLambdaLCtxt : RLambdaLCtxt ListRLambdaLCtxt1 ';' { ApplicationLCtxt $1 (reverse $2) } 
  | RLambdaLCtxt1 { $1 }


RLambdaLCtxt1 :: { RLambdaLCtxt }
RLambdaLCtxt1 : 'lambda' ListFormalLCtxt '.' RLambdaLCtxt2 { AbstractionLCtxt $2 $4 } 
  | RLambdaLCtxt2 { $1 }


RLambdaLCtxt2 :: { RLambdaLCtxt }
RLambdaLCtxt2 : ContinueLCtxt { KLCtxt $1 } 
  | FormalLCtxt { MentionLCtxt $1 }
  | ValueLCtxt { GroundLCtxt $1 }
  | '(' RLambdaLCtxt ')' { $2 }


ContinueLCtxt :: { ContinueLCtxt }
ContinueLCtxt : 'pushPrompt' RLambdaLCtxt2 RLambdaLCtxt2 { PushPromptLCtxt $2 $3 } 
  | 'withSubCont' RLambdaLCtxt2 RLambdaLCtxt2 { SubconLCtxt $2 $3 }
  | 'pushSubCont' RLambdaLCtxt2 RLambdaLCtxt2 { PushSubContLCtxt $2 $3 }


FormalLCtxt :: { FormalLCtxt }
FormalLCtxt : '@' '<' RLambdaLCtxt2 '>' { TranscriptLCtxt $3 } 


ValueLCtxt :: { ValueLCtxt }
ValueLCtxt : ValueLCtxt '+' ValueLCtxt1 { ValueAddLCtxt $1 $3 } 
  | ValueLCtxt1 { $1 }


ValueLCtxt1 :: { ValueLCtxt }
ValueLCtxt1 : ValueLCtxt1 '*' ValueLCtxt2 { ValueMultLCtxt $1 $3 } 
  | ValueLCtxt2 { $1 }


ValueLCtxt2 :: { ValueLCtxt }
ValueLCtxt2 : '-' ValueLCtxt3 { ValueNegLCtxt $2 } 
  | ValueLCtxt3 { $1 }


ValueLCtxt3 :: { ValueLCtxt }
ValueLCtxt3 : '!' ValueLiteral { ValueLitLCtxt $2 } 
  | ValueLCtxtHole { ValueEmptyLCtxt $1 }
  | '[' ValueLCtxt ']' { $2 }


ValuePCtxtHole :: { ValuePCtxtHole }
ValuePCtxtHole : UIdent { ValPPlaceHolder $1 } 
  | Wild { ValWildCard $1 }


ValueLCtxtHole :: { ValueLCtxtHole }
ValueLCtxtHole : LogicalGround { ValLPlaceHolder $1 } 


LogicalGround :: { LogicalGround }
LogicalGround : 'true' { Verity } 
  | 'false' { Absurdity }
  | 'null' { Nullity }


Comparison :: { Comparison }
Comparison : '==' { Equality } 
  | '<' { Less }
  | '>' { More }
  | '<=' { LEq }
  | '>=' { GEq }


RLambdaExpr :: { RLambdaExpr }
RLambdaExpr : RLambdaExpr ListRLambdaExpr1 ';' { Application $1 (reverse $2) } 
  | RLambdaExpr1 { $1 }


RLambdaExpr1 :: { RLambdaExpr }
RLambdaExpr1 : 'lambda' ListFormalExpr '.' RLambdaExpr2 { Abstraction $2 $4 } 
  | ContinueExpr { Continuation $1 }
  | RLambdaExpr2 { $1 }


RLambdaExpr2 :: { RLambdaExpr }
RLambdaExpr2 : FormalExpr { Mention $1 } 
  | ValueExpr { Value $1 }


ContinueExpr :: { ContinueExpr }
ContinueExpr : 'newPrompt' { Prompt } 
  | 'pushPrompt' RLambdaExpr2 RLambdaExpr2 { PushPrompt $2 $3 }
  | 'withSubCont' RLambdaExpr2 RLambdaExpr2 { Subcontinuation $2 $3 }
  | 'pushSubCont' RLambdaExpr2 RLambdaExpr2 { PushSubCont $2 $3 }


FormalExpr :: { FormalExpr }
FormalExpr : '@' '<' RLambdaExpr2 '>' { Transcription $3 } 
  | Ident { AtomLiteral $1 }


ValueExpr :: { ValueExpr }
ValueExpr : ValueExpr '+' ValueExpr1 { ValueAddExpr $1 $3 } 
  | ValueExpr1 { $1 }


ValueExpr1 :: { ValueExpr }
ValueExpr1 : ValueExpr1 '*' ValueExpr2 { ValueMultExpr $1 $3 } 
  | ValueExpr2 { $1 }


ValueExpr2 :: { ValueExpr }
ValueExpr2 : '-' ValueExpr3 { ValueNegExpr $2 } 
  | ValueExpr3 { $1 }


ValueExpr3 :: { ValueExpr }
ValueExpr3 : ValueLiteral { ValueLitExpr $1 } 
  | '[' ValueExpr ']' { $2 }


ValueLiteral :: { ValueLiteral }
ValueLiteral : '!' RecordExpr3 { ValueRecLit $2 } 
  | '(' RLambdaExpr ')' { ValueLamLit $2 }
  | Integer { ValueIntLit $1 }
  | Double { ValueDoubleLit $1 }
  | String { ValueStringLit $1 }
  | Char { ValueCharLit $1 }
  | URL { ValueURLLit $1 }


StoreURL :: { StoreURL }
StoreURL : URL { RecordStoreURL $1 } 


WireURL :: { WireURL }
WireURL : URL { RecordWireURL $1 } 


URL :: { URL }
URL : '<' URLScheme ':' URLPath '>' { BasicURL $2 $4 } 


URLPath :: { URLPath }
URLPath : '/' URLLocation URLRelativePath { LocatedtedPath $2 $3 } 


URLLocation :: { URLLocation }
URLLocation : URLRoot URLRsrcLocation { URLNetLocation $1 $2 } 


URLRsrcLocation :: { URLRsrcLocation }
URLRsrcLocation : NetLocation ':' Port { URLRsrcPortLoc $1 $3 } 
  | NetLocation { URLRsrcLoc $1 }


URLRelativePath :: { URLRelativePath }
URLRelativePath : URLRoot ListURLPathElement { SlashPath $1 $2 } 


URLRoot :: { URLRoot }
URLRoot : '/' { URLOrigin } 


NetLocation :: { NetLocation }
NetLocation : ListDNSElement { DNSAddr $1 } 


URLScheme :: { URLScheme }
URLScheme : Ident { AtomScheme $1 } 


URLPathElement :: { URLPathElement }
URLPathElement : Ident { AtomPathElement $1 } 


DNSElement :: { DNSElement }
DNSElement : Ident { AtomDNSElement $1 } 


Port :: { Port }
Port : Integer { AtomPort $1 } 


ListBinding :: { [Binding] }
ListBinding : {- empty -} { [] } 
  | Binding { (:[]) $1 }
  | Binding ',' ListBinding { (:) $1 $3 }


ListDomainDeclOrCond :: { [DomainDeclOrCond] }
ListDomainDeclOrCond : {- empty -} { [] } 
  | DomainDeclOrCond { (:[]) $1 }
  | DomainDeclOrCond ',' ListDomainDeclOrCond { (:) $1 $3 }


ListDomainExpr :: { [DomainExpr] }
ListDomainExpr : {- empty -} { [] } 
  | DomainExpr { (:[]) $1 }
  | DomainExpr ',' ListDomainExpr { (:) $1 $3 }


ListDomainPtn :: { [DomainPtn] }
ListDomainPtn : {- empty -} { [] } 
  | DomainPtn { (:[]) $1 }
  | DomainPtn ',' ListDomainPtn { (:) $1 $3 }


ListFormalExpr :: { [FormalExpr] }
ListFormalExpr : {- empty -} { [] } 
  | FormalExpr { (:[]) $1 }
  | FormalExpr ',' ListFormalExpr { (:) $1 $3 }


ListRLambdaExpr1 :: { [RLambdaExpr] }
ListRLambdaExpr1 : {- empty -} { [] } 
  | ListRLambdaExpr1 RLambdaExpr1 { flip (:) $1 $2 }


ListFormalPCtxt :: { [FormalPCtxt] }
ListFormalPCtxt : {- empty -} { [] } 
  | FormalPCtxt { (:[]) $1 }
  | FormalPCtxt ',' ListFormalPCtxt { (:) $1 $3 }


ListRLambdaPCtxt1 :: { [RLambdaPCtxt] }
ListRLambdaPCtxt1 : {- empty -} { [] } 
  | ListRLambdaPCtxt1 RLambdaPCtxt1 { flip (:) $1 $2 }


ListFormalLCtxt :: { [FormalLCtxt] }
ListFormalLCtxt : {- empty -} { [] } 
  | FormalLCtxt { (:[]) $1 }
  | FormalLCtxt ',' ListFormalLCtxt { (:) $1 $3 }


ListRLambdaLCtxt1 :: { [RLambdaLCtxt] }
ListRLambdaLCtxt1 : {- empty -} { [] } 
  | ListRLambdaLCtxt1 RLambdaLCtxt1 { flip (:) $1 $2 }


ListURLPathElement :: { [URLPathElement] }
ListURLPathElement : {- empty -} { [] } 
  | URLPathElement { (:[]) $1 }
  | URLPathElement '/' ListURLPathElement { (:) $1 $3 }


ListDNSElement :: { [DNSElement] }
ListDNSElement : {- empty -} { [] } 
  | DNSElement { (:[]) $1 }
  | DNSElement '.' ListDNSElement { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map prToken (take 4 ts))

myLexer = tokens
}

